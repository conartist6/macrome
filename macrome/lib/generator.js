'use strict';

const fs = require('fs');
const { relative, dirname } = require('path');
// const { EOL } = require('os');

const { Matchable } = require('./matchable');
const operations = require('./operations');

const commentLines = [
  'This file is autogenerated. Please do not edit it directly.',
  'When editing run `npx macrome watch` then change the file this is generated from.',
];

class Generator extends Matchable {
  constructor(macrome, options) {
    super();
    this._macrome = macrome;
    this.options = options;
    if (!this.options.parser) {
      throw new Error('Generator instantiated without options.parser');
    }
  }

  get operations() {
    return operations;
  }

  get macrome() {
    return this._macrome;
  }

  get parser() {
    return this.options.parser;
  }

  get logger() {
    return this.macrome.logger;
  }

  get generatedPaths() {
    return this.macrome.generatedPaths;
  }

  resolve(path) {
    return this.macrome.resolve(path);
  }

  read(path) {
    return fs.readFileSync(this.macrome.resolve(path), 'utf8');
  }

  parse(content) {
    return this.parser.parse(content, this.options.parseOptions);
  }

  print(ast) {
    return this.parser.print(ast, this.options.printOptions);
  }

  generateError(e) {
    return this.parser.generateError(e);
  }

  write(path, content) {
    this.macrome.write(path, content);
  }

  unlink(path) {
    this.macrome.unlink(path);
  }

  decorate(ast, annotations) {
    this.parser.stripHeader(ast);
    this.parser.prependHeader(ast, annotations, commentLines);
  }

  getAnnotations(destPath, sourcePath = null) {
    let fromAnnotations = {};

    if (sourcePath) {
      const relPath = relative(dirname(destPath), sourcePath);
      fromAnnotations = {
        'generated-from': relPath.startsWith('.') ? relPath : `./${relPath}`,
      };
    }

    return {
      macrome: true,
      ...fromAnnotations,
      'generated-by': this.options.vcsPath,
    };
  }
}

module.exports = { Generator };
